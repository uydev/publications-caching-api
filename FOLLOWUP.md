# Follow-up Questions

1. **What libraries did you use? Why did you use them?**
    The web application utilizes the Laravel Framework, leveraging its built-in features such as routing, controllers, and Eloquent ORM for database migration file. Additionally, I used the Illuminate\Http\Request library to manage HTTP requests and access query parameters. I used PHPUnit for testing purposes, ensuring the application functions as expected. These libraries and components were chosen for their seamless integration with Laravel, streamlining tasks like HTTP requests, database interactions, logging, and testing.

2. **If you had more time, what further improvements or new features would you add?**
    Given additional time, several enhancements and new features could be implemented to further improve the application. Firstly, an enhanced caching strategy could be implemented, incorporating advanced solutions like Redis or Memcached to enhance performance and scalability. Furthermore, refining error handling mechanisms, particularly when communicating with CrossRef, including implementing retry logic for transient errors, would fortify the application's resilience. Introducing pagination and filtering functionalities for returning multiple publications from the cache would enhance user experience and facilitate easier data navigation. Additionally, implementing API rate limiting would be crucial to safeguard the application from abuse and efficiently manage API quotas. To enhance operational visibility and monitoring, detailed logging with comprehensive information and the integration of monitoring tools could be implemented to monitor the application's health and performance effectively. Lastly, incorporating user authentication and authorization mechanisms would bolster the application's security, ensuring that only authorized users can access and interact with the endpoints securely. These enhancements collectively contribute to the application's robustness, scalability, and security posture.

3. **Which parts are you most proud of? And why?**
    Firstly, the caching mechanism stands out for its efficiency in leveraging local cache checks prior to querying CrossRef, optimizing resource usage and enhancing response times. Secondly, the extensive test suite, covering a wide range of scenarios, highlights the reliability and accuracy of the API. Lastly, the clear and well-structured organization of the controller, model and route enhances the codebase's readability and maintainability, facilitating ease of understanding and future modifications.

4. **Which parts did you spend the most time with? What did you find most difficult?**
    Implementing the logic to check for partial DOI matches and managing the caching mechanism took significant time to ensure it worked correctly. Setting up the PHPUnit tests and implementing the PublicationController, which involved crafting response logic and handling various HTTP statuses and response formats, as well as mocking external API responses, demanded careful attention to detail.